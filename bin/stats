#!/usr/bin/python

import hashlib
import json
import socket
import sys
import time
import xml.etree.ElementTree as ET

def boinc_auth_conn(s, key):
    # send the initial authorization request
    s.sendall(b'<auth1/>\003')
    # get the reply, stringify it from bytes, strip the trailing
    # ETX, and turn that into a tree
    reply = ET.fromstring(s.recv(1024).decode('utf-8').strip('\003'))
    # hash the nonce contained in the reply with our password
    m = hashlib.md5()
    m.update(bytearray(reply[0].text, 'utf-8'))
    m.update(bytearray(key, 'utf-8'))
    nonce_hash = m.hexdigest()
    # then send it
    req = "<auth2><nonce_hash>" + nonce_hash + "</nonce_hash></auth2>\003"
    s.sendall(req.encode('utf-8'))
    # repeat the receive-and-decode dance. check answer.
    reply = ET.fromstring(s.recv(1024).decode('utf-8').strip('\003'))
    if reply[0].tag == "authorized":
        return True
    else:
        return False

def recv_msg(s):
    chunks = []
    msgend = False
    while not msgend:
        chunk = s.recv(4096)
        if chunk == b'':
            raise RuntimeError("socket connection broken")
        if chunk[-1] == 3:
            msgend = True
        chunks.append(chunk)
    return b''.join(chunks).decode('utf-8').strip('\003')


def format_eta(eta):
    eta = float(eta)
    if eta > 3600:
        h = int(eta / 3600)
        m = int((eta - 3600 * h) / 60)
        return "{:3d}h{:02d}m".format(h, m)
    else:
        m = int(eta / 60)
        s = int(eta - 60 * m)
        return "{:3d}m{:02d}s".format(m, s)


def format_dl(dl):
    od = 1
    dl = int(float(dl))
    t = int(time.time())
    dl = dl - t
    if dl < 0:
        od = -1
        dl = abs(dl)

    if dl > 86400:
        d = int(dl / 86400) * od
        h = int((dl - 86400 * d) / 3600)
        return "{:3d}d{:02d}h".format(d, h)
    elif dl > 3600:
        h = int(dl / 3600) * od
        m = int((dl - 3600 * h) / 60)
        return "{:3d}h{:02d}m".format(h, m)
    else:
        m = int(dl / 60) * od
        s = int(dl - 60 * m)
        return "{:3d}m{:02d}s".format(m, s)



hosts = {}
projects = {}
tasks = None
hostcount = 0
wanthost = ""
wantjson = False

sys.argv.pop(0)
tmpfile = sys.argv.pop(0)

# handle optional args
for arg in sys.argv:
    if arg == "json":
        wantjson = True
    elif arg == "nopage":
        pass
    else:
        wanthost = arg

of = open(tmpfile, 'w')
with open("/homefarm/.boincguikeys.json", 'r') as f:
    hosts = json.load(f)

for host, key in hosts.items():
    if wanthost != "" and host != wanthost:
        continue

    projects = {}
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        try:
            s.connect((host, 31416))
        except:
            of.write("warning: could not connect to '{}' with key '{}'\n".format(host, key))
            continue
        # try to auth
        authed = boinc_auth_conn(s, key)
        if not authed:
            of.write("warning: could not auth on '{}' with key '{}'\n".format(host, key))
            continue

        # first, get projects data
        req = "<boinc_gui_rpc_request><get_project_status/></boinc_gui_rpc_request>\003"
        s.sendall(req.encode('utf-8'))
        reply = ET.fromstring(recv_msg(s))
        for project in reply.iter('project'):
            # and extract a few bits on a per-project basis. some of
            # this is trivia, but some of it will let us process the
            # tasks meaningfully
            p = {}
            name = project.find('project_name').text
            p['url'] = project.find('master_url').text
            p['username'] = project.find('user_name').text
            p['usercred'] = int(float(project.find('user_total_credit').text))
            p['userrac'] = int(float(project.find('user_expavg_credit').text))
            p['hostcred'] = int(float(project.find('host_total_credit').text))
            p['hostrac'] = int(float(project.find('host_expavg_credit').text))
            try:
                state = project.find('suspended_via_gui')
                if state is not None:
                    p['state'] = "Suspended"
            except:
                pass
            try:
                state = project.find('dont_request_more_work')
                if state is not None:
                    p['state'] = "Nomorework"
            except:
                pass
            if 'state' not in p:
                p['state'] = "Active"
            projects[name] = p

        # now just grab the task data and stow it. we'll process it
        # later on
        req = "<boinc_gui_rpc_request><get_results/></boinc_gui_rpc_request>\003"
        s.sendall(req.encode('utf-8'))
        tasks = ET.fromstring(recv_msg(s))

    if hostcount > 0:
        of.write("\n\n\n")
    of.write("================================================================================\n")
    of.write("{}\n".format(host))
    of.write("================================================================================\n")
    if len(projects) == 0:
        of.write("No work from this project (yet?)\n")
        continue

    projcount = 0
    for projname in sorted(projects):
        task_count = 0  # how many tasks in this project
        task_active = 0 # how many active tasks
        wunum = 1       # counter for printing task details
        ptasks = {}     # dict of tasks for this project

        # loop over the tasks, extracting interesting info
        for task in tasks.iter('result'):
            # only process tasks belonging to the current project
            if projects[projname]['url'] != task.find('project_url').text:
                continue
            task_count += 1
            t = {}

            # stuff
            t['cpu_eta'] = task.find('estimated_cpu_time_remaining').text
            t['state'] =  task.find('state').text
            t['deadline'] = task.find('report_deadline').text
            # if the task is active
            try:
                active_data = task.find('active_task')
                if active_data is None:
                    raise
                task_active += 1
                t['active'] = True
                t['done'] = float(active_data.find('fraction_done').text)
                t['cpu_elapsed'] = active_data.find('current_cpu_time').text
                astate = float(active_data.find('active_task_state').text)
                # set a human-readable active state
                if astate == 0:
                    t['astate'] = "Paus"
                elif astate == 1:
                    t['astate'] = "Run"
                elif astate == 5:
                    t['astate'] = "Abrt"
                elif astate == 8:
                    t['astate'] = "Quit"
                elif astate == 9:
                    t['astate'] = "Susp"
                else: # 10
                    t['astate'] = "Copy"
            except:
                t['active'] = False
                t['done'] = 0
            # add the task to the list
            ptasks[task.find('name').text] = t

        # print a summary for the project
        p = projects[projname]
        if projcount > 0:
            of.write("--------------------------------------------------------------------------------\n")
        of.write("{}\t  User: {}\t  State: {}\n".format(projname, p['username'], p['state']))
        of.write("Tasks: {}\t  Active: {}\t  Credit/RAC: {}/{}\n".format(task_count, task_active, int(p["hostcred"]), int(p["hostrac"])))
        projcount += 1
        # if there are no active tasks for this project, don't do
        # detail reporting
        if task_active == 0:
            continue
        # ok, we have active tasks. print details.
        of.write("\n")
        of.write("     Workunit                                     Stat  Prog    ETA      Dline\n")
        of.write("     -------------------------------------------  ----  ------  -------  -------\n")
        # sort tasks by completion percentage and iterate over them,
        # printing details for active ones
        for name, t in {k: v for k, v in sorted(ptasks.items(), reverse=True, key=lambda item: item[1]['done'])}.items():
            if not t['active']:
                continue
            of.write("{:3d}  {:43}  {:4}  {:6.2%}  {}  {}\n".format(wunum, name[:43], t['astate'], t['done'], format_eta(t['cpu_eta']), format_dl(t['deadline'])))
            wunum += 1
    hostcount += 1
