#!/bin/env python3

#
# query - parse and operate on BOINC job logs
#

import argparse
import glob
import json
import os
import socket
import sys
import time
import xml.etree.ElementTree as ET

import homefarm

def printout():
    if args.json:
        print(json.dumps(jsondata))
    else:
        for line in report: print(line)
        print()


# set up and handle arguments
parser = argparse.ArgumentParser(description='parse BOINC job logs')
parser.add_argument('-p', '--project', metavar='PROJECT_NAME', dest="proj", default="ALL",
                    help="partial name of the joblog to be parsed. must be unique")
parser.add_argument('-t', '--type', metavar='WU_TYPE', dest="wutype", default=None,
                    help="the workunit type/name to filter by (e.g. MCM1)")
parser.add_argument('-s', '--timespan', metavar='HOURS', dest="span", type=int, default=24,
                    help="how many hours of logs to parse (default: 24)")
parser.add_argument('-c', '--count-only', dest="count", action="store_true",
                    help="show WU counts only; do not print min/max/quintile times")
parser.add_argument('-j', '--json', dest="json", action="store_true",
                    help="output data as JSON")
args = parser.parse_args()

# set up our hostname + report banner
hostname = socket.gethostname()
banner = ("-" * (79 - len(hostname))) + " " + hostname
# initialize the JSON data
jsondata = { 'host': hostname, 'proj': args.proj, 'wutype':args.wutype, 'span': args.span,
             'matches': None, 'cputime': None, 'err': None }
# calculate our timespan for log matches
timelimit = int(time.mktime(time.localtime()) - (3600 * args.span))

# turn args.proj into a set of joblog filepaths (but only one for now)
joblogs = []
if args.proj == "ALL":
    joblogs = glob.glob("/var/lib/boinc/job_log_*.txt")
else:
    globpath = "/var/lib/boinc/job_log_*{}*.txt".format(args.proj)
    joblogs = glob.glob(globpath)
    if len(joblogs) == 0:
        if args.json:
            jsondata['err'] = "no matching attached projects"
            print(json.dumps(jsondata))
        else:
            print("{}: Can't find any attached projects matching '{}'".format(hostname, args.proj))
        sys.exit(0)
    if len(joblogs) > 1:
        if args.json:
            jsondata['err'] = "multiple matching projects; must have exactly one"
            print(json.dumps(jsondata))
        else:
            print("{}: Found multiple projects matching '{}'; must have exactly one match".format(hostname, args.proj))
        sys.exit(0)

# get project info, so we can use proper, repeatable project names
# rather than the string we were initially handed
key=""
with open('/var/lib/boinc/gui_rpc_auth.cfg', 'r') as f:
    key=f.readline()
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    try:
        s.connect((hostname, 31416))
    except:
        print("warning: could not connect to '{}' with key '{}'\n".format(hostname, key))
        sys.exit(0)
    # try to auth
    authed = homefarm.auth_conn(s, key)
    if not authed:
        print("warning: could not auth on '{}' with key '{}'\n".format(hostname, key))
        sys.exit(0)
    req = "<boinc_gui_rpc_request><get_project_status/></boinc_gui_rpc_request>\003"
    s.sendall(req.encode('utf-8'))
    reply = ET.fromstring(homefarm.recv_msg(s))
    for p in reply.iter('project'):
        url = p.find('master_url').text
        if args.proj in url:
            jsondata['proj'] = p.find('project_name').text
        else:
            continue



matches = []
cputime = 0
f = None

# The zeroth column is the log time (Unix style -- milliseconds since 1/1/1970 UTC)
# 1  2
# ue estimated run time of the work unit
# 3  4
# ct actual CPU time
# 5  6
# fe estimated flops
# 7  8
# nm work unit name
# 9  10
# et elapsed time (work unit wall clock time)
# 11 12
# es status (rc)
for joblog in joblogs:
    try:
        f = open(joblog, 'r')
    except:
        if args.json:
            jsondata['err'] = "not attached"
            print(json.dumps(jsondata))
        else:
            print("\tNot attached")
        sys.exit(0)

    for line in f:
        line = line.rstrip("\n")
        # split line into fields: see above
        fields = line.split()
        # skip this line if it's not within our timespan
        if int(fields[0]) < timelimit:
            continue
        # skip line if it's not the type/name we're looking for
        if args.wutype != None:
            if args.wutype not in fields[8]:
                continue
        time = round(float(fields[4]))
        matches.append(time)
        cputime += time

jsondata['matches'] = len(matches)
jsondata['cputime'] = cputime
report = []

report.append(banner)
if args.wutype != None:
    report.append("WUs matching '{}' for {} in past {} hours: {}".format(args.wutype, jsondata['proj'], args.span, jsondata['matches']))
else:
    report.append("WUs for {} in past {} hours: {}".format(jsondata['proj'], args.span, jsondata['matches']))
report.append("Total CPU time used:  {}".format(homefarm.strtime(cputime)))
if len(matches) == 0 or args.count:
    printout()
    sys.exit(0)

mintime = min(matches)
maxtime = max(matches)
avgtime = sum(matches)/len(matches)
jsondata['times'] = [ mintime, maxtime, avgtime ]
report.append("\tMin runtime: {}".format(homefarm.strtime(mintime)))
report.append("\tMax runtime: {}".format(homefarm.strtime(maxtime)))
report.append("\tAvg runtime: {}".format(homefarm.strtime(avgtime)))
if len(matches) < 2:
    printout()
    sys.exit(0)

jsondata['quints'] = []
report.append("WUs by quintile:")
qspan = int((max(matches) -  min(matches)) / 5)
q = [ min(matches) + qspan, min(matches) + qspan * 2, min(matches) + qspan * 3,
      min(matches) + qspan * 4, max(matches) ]
qcounts = [0, 0, 0, 0, 0]
for m in matches:
    if m >= min(matches) and m < q[0]:
        qcounts[0] += 1
    elif m >= q[0] and m < q[1]:
        qcounts[1] += 1
    elif m >= q[1] and m < q[2]:
        qcounts[2] += 1
    elif m >= q[2] and m < q[3]:
        qcounts[3] += 1
    else:
        qcounts[4] += 1
for i in range(5):
    jsondata['quints'].append([q[i], qcounts[i],  qcounts[i] / len(matches) * 100])
    report.append("\t<= {}\t {}\t ({:04.1f}%)".format(homefarm.strtime(q[i]), qcounts[i],
                                                      qcounts[i] / len(matches) * 100))

printout()
