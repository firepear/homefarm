#!/bin/env python3

#
# jlparse - parse and operate on BOINC job logs
#

# > The first column is the log time (Unix style -- milliseconds since 1/1/1970 UTC)
# > ue: estimated run time of the work unit
# > ct: actual CPU time
# > fe: estimated flops
# > nm: work unit name
# > et: elapsed time (work unit wall clock time)

import argparse
import glob
import os
import sys
import time


def strtime(time):
    hours = 0
    mins = 0
    timestr = ""
    if time > 3600:
        hours = int(time / 3600)
        time = time - (3600 * hours)
    if time > 60:
        mins = int(time / 60)
        time = time - (60 * mins)
    return "{:02d}h {:02d}min {:02d}s".format(hours, mins, int(time))


########################################################################
# main script begins

# set up and handle arguments
parser = argparse.ArgumentParser(description='parse BOINC job logs')
parser.add_argument('-p', '--project', metavar='PROJECT_NAME', dest="projurl", required=True,
                    help="partial name of the joblog to be parsed. must be unique")
parser.add_argument('-t', '--type', metavar='WU_TYPE', dest="wutype", default=None,
                    help="the workunit type/name to filter by (e.g. MCM1)")
parser.add_argument('-s', '--timespan', metavar='HOURS', dest="span", type=int, default=24,
                    help="how many hours of logs to parse (default: 24)")
parser.add_argument('-c', '--count-only', dest="count", action="store_true",
                    help="show WU counts only; do not print min/max/quintile times")
args = parser.parse_args()

# turn args.projurl into a joblog filepath
globpath = "/var/lib/boinc/job_log_*{}*.txt".format(args.projurl)
joblogs = glob.glob(globpath)
if len(joblogs) == 0:
    print("Can't find any attached projects matching '{}'".format(args.projurl))
    sys.exit(2)
if len(joblogs) > 1:
    print("Found multiple projects matching '{}'; must have exactly one match".format(args.projurl))
    sys.exit(2)
args.projurl = joblogs[0]
# and the timespan
timelimit = int(time.mktime(time.localtime()) - (3600 * args.span))

matches = []
f = None

try:
    f = open(args.projurl, 'r')
except:
    print("\tNot attached")
    sys.exit(0)

for line in f:
    line = line.rstrip("\n")
    # split line into fields:
    # 0:timestamp 2:est_runtime 4:runtime 6:est_flops 8:name 10:credit 12:status
    fields = line.split()
    # skip this line if it's not within our timespan
    if int(fields[0]) < timelimit:
        continue
    # skip line if it's not the type/name we're looking for
    if args.wutype != None:
        if args.wutype not in fields[8]:
            continue
    matches.append(int(float(fields[4])))


print("WUs in past {} hours: {}".format(args.span, len(matches)))
if len(matches) == 0:
    sys.exit(0)
if args.count:
    sys.exit(0)

mintime = strtime(min(matches))
maxtime = strtime(max(matches))
avgtime = strtime(sum(matches)/len(matches))
print("\tMin runtime: {}".format(mintime))
print("\tMax runtime: {}".format(maxtime))
print("\tAvg runtime: {}".format(avgtime))
if len(matches) < 2:
    sys.exit(0)

print("WUs by quintile:")
qspan = int((max(matches) -  min(matches)) / 5)
q = [ min(matches) + qspan, min(matches) + qspan * 2, min(matches) + qspan * 3,
      min(matches) + qspan * 4, max(matches) ]
qcounts = [0, 0, 0, 0, 0]
for m in matches:
    if m >= min(matches) and m < q[0]:
        qcounts[0] += 1
    elif m >= q[0] and m < q[1]:
        qcounts[1] += 1
    elif m >= q[1] and m < q[2]:
        qcounts[2] += 1
    elif m >= q[2] and m < q[3]:
        qcounts[3] += 1
    else:
        qcounts[4] += 1
for i in range(5):
    print("\t<= {}\t {}\t ({:04.1f}%)".format(strtime(q[i]), qcounts[i],
                                              qcounts[i] / len(matches) * 100))
